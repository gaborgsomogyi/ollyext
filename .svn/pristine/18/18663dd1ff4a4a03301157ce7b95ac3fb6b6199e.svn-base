#include "stdafx.h"
#include "plugin.h"
#include "OllyExt.h"
#include "OllyExtProtect.h"


sOptions g_options = { 0 };


#define ISDEBUGGERPRESENT L"isDebuggerPresent"
static BYTE g_isDebuggerPresentPatch[] = { 0x31, 0xC0, 0xC3 };


void protectReadOptions( void )
{
	Getfromini( NULL, PLUGIN_NAME, ISDEBUGGERPRESENT, L"%d", &g_options.isDebuggerPresent );
}


void protectWriteOptions( void )
{
	Writetoini( NULL, PLUGIN_NAME, ISDEBUGGERPRESENT, L"%d", g_options.isDebuggerPresent );
}


void protectApplyPatch( wchar_t* libName, char* procName, BYTE* patch, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return, L"No active debugge found to hook" );

	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return, L"Unable to find module: %ws", libName );

	FARPROC address = GetProcAddress( module, procName );
	if( !address )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return, L"Unable to find function: %ws::%s", libName, procNameW );
	}

	BOOL success = WriteProcessMemory( process, (void*)address, patch, size, NULL );
	PLUGIN_CHECK_ERROR( success, return, L"Unable to write debugge memory at: %08X", address );
}


void protectApply( void )
{
	PLUGIN_CHECK_ERROR( process, return, L"No active debugge found to hook" );

	if( g_options.isDebuggerPresent )
		protectApplyPatch( L"kernel32.dll", "IsDebuggerPresent", g_isDebuggerPresentPatch, sizeof( g_isDebuggerPresentPatch ) );
}
