#include "stdafx.h"
#include "OllyExtVersion.h"
#include "OllyExtAbout.h"
#include "OllyExtIcon.h"
#include "OllyExtProtect.h"
#include "OllyExtBugfixes.h"
#include "OptionsDialog.h"


#define PROTECT_GET_OPTION_FROM_DLG( tab, control, option ) \
{ \
	HWND hwnd = GetDlgItem( g_tabs[tab].hwnd, control ); \
	option = SendMessage( hwnd, BM_GETSTATE, 0, 0 ) == BST_CHECKED; \
}

#define PROTECT_SET_DLG_FROM_OPTION( tab, control, option ) \
{ \
	HWND hwnd = GetDlgItem( g_tabs[tab].hwnd, control ); \
	SendMessage( hwnd, BM_SETCHECK, option ? BST_CHECKED : BST_UNCHECKED, 0 ); \
}


typedef enum
{
	TAB_ANTI_DEBUG,
	TAB_BUGFIXES,
	TAB_NUM
} eTabType;

typedef struct
{
	wchar_t* name;
	DWORD id;
	HWND hwnd;
} sTab;

static sTab g_tabs[TAB_NUM] =
{
	{ L"Anti-Debug", IDD_TAB1, NULL },
	{ L"Bugfixes", IDD_TAB2, NULL }
};

static int g_selectedTab = 0;


static void createTabs( HWND hDlg )
{
	HWND hTab = GetDlgItem( hDlg, IDC_OPTIONS_TAB );
	if( !hTab ) return;

	RECT tabRect = { 0 };
	GetWindowRect( hTab, &tabRect );

	LONG itemYMax = 0;
	LONG w = tabRect.right - tabRect.left;
	LONG h = tabRect.bottom- tabRect.top;

	TCITEM tcItem;
	for( DWORD i = 0; i < sizeof( g_tabs ) / sizeof( g_tabs[0] ); ++i )
	{
		memset( &tcItem, 0, sizeof( TCITEM ) );
		tcItem.mask = TCIF_TEXT;
		tcItem.pszText = g_tabs[i].name;

		if( TabCtrl_InsertItem( hTab, i, &tcItem ) == -1 ) return;

		RECT itemRect = { 0 };
		TabCtrl_GetItemRect( hTab, i, &itemRect );
		if( itemYMax < itemRect.bottom )
			itemYMax = itemRect.bottom;
	}

	for( DWORD i = 0; i < sizeof( g_tabs ) / sizeof( g_tabs[0] ); ++i )
	{
		g_tabs[i].hwnd = CreateDialog( g_instance, MAKEINTRESOURCE( g_tabs[i].id ), hTab, NULL );
		SetWindowPos( g_tabs[i].hwnd,
						NULL,
						0,
						itemYMax,
						w,
						h,
						0 );
		ShowWindow( g_tabs[i].hwnd, SW_HIDE );
	}

	g_selectedTab = 0;
	ShowWindow( g_tabs[g_selectedTab].hwnd, SW_SHOW );
}


static void setOptions( HWND hDlg )
{
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_ISDEBUGGERPRESENT, g_protectOptions.isDebuggerPresent );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_NTGLOBALFLAG, g_protectOptions.ntGlobalFlag );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_HEAPFLAGS, g_protectOptions.heapFlags );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_FORCEFLAGS, g_protectOptions.forceFlags );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_CHECKREMOTEDEBUGGERPRESENT, g_protectOptions.checkRemoteDebuggerPresent );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_OUTPUTDEBUGSTRING, g_protectOptions.outputDebugString );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_CLOSEHANDLE, g_protectOptions.closeHandle );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_SEDEBUGPRIVILEGE, g_protectOptions.seDebugPrivilege );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_BLOCKINPUT, g_protectOptions.blockInput );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_PROCESSDEBUGFLAGS, g_protectOptions.processDebugFlags );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_PROCESSDEBUGOBJECTHANDLE, g_protectOptions.processDebugObjectHandle );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_TERMINATEPROCESS, g_protectOptions.terminateProcess );
	PROTECT_SET_DLG_FROM_OPTION( TAB_ANTI_DEBUG, IDC_SETINFORMATIONTHREAD, g_protectOptions.setInformationThread );

	PROTECT_SET_DLG_FROM_OPTION( TAB_BUGFIXES, IDC_CAPTION, g_bugfixOptions.caption );
}


BOOL CALLBACK OptionsDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch( msg )
	{
	case WM_INITDIALOG:
	{
		SetWindowText( hDlg, g_versionStr );

		SendMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM)g_hIconSmall );
		SendMessage( hDlg, WM_SETICON, ICON_BIG, (LPARAM)g_hIconBig );

		createTabs( hDlg );
		setOptions( hDlg );

		return TRUE;
	}
	break;

	case WM_DESTROY:
	case WM_CLOSE:
		EndDialog( hDlg, 0 );
		return TRUE;
	break;

	case WM_COMMAND:
        switch( HIWORD( wParam ) )
        {
        case BN_CLICKED:       
			switch( LOWORD( wParam ) )
			{
			case IDC_OK:
			{
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_ISDEBUGGERPRESENT, g_protectOptions.isDebuggerPresent );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_NTGLOBALFLAG, g_protectOptions.ntGlobalFlag );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_HEAPFLAGS, g_protectOptions.heapFlags );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_FORCEFLAGS, g_protectOptions.forceFlags );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_CHECKREMOTEDEBUGGERPRESENT, g_protectOptions.checkRemoteDebuggerPresent );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_OUTPUTDEBUGSTRING, g_protectOptions.outputDebugString );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_CLOSEHANDLE, g_protectOptions.closeHandle );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_SEDEBUGPRIVILEGE, g_protectOptions.seDebugPrivilege );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_BLOCKINPUT, g_protectOptions.blockInput );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_PROCESSDEBUGFLAGS, g_protectOptions.processDebugFlags );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_PROCESSDEBUGOBJECTHANDLE, g_protectOptions.processDebugObjectHandle );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_TERMINATEPROCESS, g_protectOptions.terminateProcess );
				PROTECT_GET_OPTION_FROM_DLG( TAB_ANTI_DEBUG, IDC_SETINFORMATIONTHREAD, g_protectOptions.setInformationThread );

				protectWriteOptions();
				if( process ) protectApply();

				PROTECT_GET_OPTION_FROM_DLG( TAB_BUGFIXES, IDC_CAPTION, g_bugfixOptions.caption );

				bugfixesWriteOptions();
				bugfixesApply();

				EndDialog( hDlg, 0 );
				return TRUE;
			}
			break;

			case IDC_CANCEL:
				EndDialog( hDlg, 0 );
				return TRUE;
			break;

			case IDC_ABOUT:
				aboutShow();
				return TRUE;
			break;
			}
        break;
        }
	break;

	case WM_NOTIFY:
	{
		LPNMHDR lpnmhdr = (LPNMHDR)lParam;
		switch( lpnmhdr->code )
        {
        case TCN_SELCHANGE:
			switch( lpnmhdr->idFrom )
			{
			case IDC_OPTIONS_TAB:
				int pageID = TabCtrl_GetCurSel( lpnmhdr->hwndFrom );
				if( pageID >= 0 )
				{
					ShowWindow( g_tabs[g_selectedTab].hwnd, SW_HIDE );
					g_selectedTab = pageID;
					ShowWindow( g_tabs[g_selectedTab].hwnd, SW_SHOW );
				}
				return TRUE;
			break;
			}
        break;
        }
	}
	break;
	}

	return FALSE;
}
