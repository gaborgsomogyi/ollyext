#include "stdafx.h"
#include "OllyExtHook.h"


#define UNCONDITIONAL_JMP_SIZE ( 5 )


FARPROC hookGetProcAddress( HANDLE hProcess, wchar_t* libName, char* procName )
{
	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return NULL;, UNABLE_TO_FIND_MODULE, libName );

	FARPROC procAddressToPatch = GetProcAddress( module, procName );
	if( !procAddressToPatch )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return NULL;, UNABLE_TO_FIND_FUNCTION, libName, procNameW );
	}

	return procAddressToPatch;
}


bool hookAlloc( HANDLE hProcess, wchar_t* libName, char* procName, sHook& rHook )
{
	BOOL writeResult = FALSE;
	wchar_t cmd[32] = { 0 };
	DWORD codeLen = 0;
	wchar_t assemblyError[TEXTLEN] = { 0 };

	// Get API address
	rHook.remoteTargetProc = hookGetProcAddress( hProcess, libName, procName );
	if( !rHook.remoteTargetProc )
		return false;

	// Get number of bytes has to be saved into trampoline
	DWORD apiOrigCodeSize = 0;
	DWORD ptr = (DWORD)rHook.remoteTargetProc;
	while( apiOrigCodeSize < UNCONDITIONAL_JMP_SIZE )
	{
		t_cmdinfo ci;
		DWORD codeLen = Cmdinfo( (BYTE*)ptr, MAXCMDSIZE, ptr, &ci, 0, NULL );
		PLUGIN_CHECK_ERROR( codeLen, return false;, UNABLE_TO_DISASSEMBLE_CODE, ptr );
		ptr += codeLen;
		apiOrigCodeSize += codeLen;
	}

	// Calculate trampoline proc size
	rHook.trampolineProcSize = apiOrigCodeSize + UNCONDITIONAL_JMP_SIZE;

	// Allocate trampoline proc
	rHook.trampolineProc = VirtualAllocEx( hProcess, NULL, rHook.trampolineProcSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
	PLUGIN_CHECK_ERROR( rHook.trampolineProc, return false;, UNABLE_TO_ALLOCATE_REMOTE_MEMORY );

	// Copy the original data from target API function to trampoline
	writeResult = WriteProcessMemory( hProcess, rHook.trampolineProc, rHook.remoteTargetProc, apiOrigCodeSize, NULL );
	PLUGIN_CHECK_ERROR( writeResult,
		VirtualFreeEx( hProcess, rHook.trampolineProc, 0, MEM_RELEASE ); \
		return false;,
		UNABLE_TO_WRITE_MEMORY_AT, rHook.trampolineProc );

	// Assemble an unconditional jump back to the target API function
	BYTE jmpToOrigFunc[UNCONDITIONAL_JMP_SIZE] = { 0 };
	wsprintf( cmd, L"jmp 0x%08X", (DWORD)rHook.remoteTargetProc + apiOrigCodeSize );
	codeLen = Assemble( cmd, (DWORD)rHook.trampolineProc + apiOrigCodeSize, jmpToOrigFunc, UNCONDITIONAL_JMP_SIZE, 0, assemblyError );
	PLUGIN_CHECK_ERROR( codeLen,
		VirtualFreeEx( hProcess, rHook.trampolineProc, 0, MEM_RELEASE ); \
		return false;,
		UNABLE_TO_ASSEMBLE_CODE, cmd, (DWORD)(rHook.trampolineProc) + apiOrigCodeSize, assemblyError );

	// Copy this unconditional jump into trampoline
	writeResult = WriteProcessMemory( hProcess, (void*)( (DWORD)rHook.trampolineProc + apiOrigCodeSize ), jmpToOrigFunc, UNCONDITIONAL_JMP_SIZE, NULL );
	PLUGIN_CHECK_ERROR( writeResult,
		VirtualFreeEx( hProcess, rHook.trampolineProc, 0, MEM_RELEASE ); \
		return false;,
		UNABLE_TO_WRITE_MEMORY_AT, (DWORD)rHook.trampolineProc + apiOrigCodeSize );

	// Allocate hook proc
	rHook.remoteHookProc = VirtualAllocEx( hProcess, NULL, rHook.hookSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
	PLUGIN_CHECK_ERROR( rHook.remoteHookProc,
		VirtualFreeEx( hProcess, rHook.trampolineProc, 0, MEM_RELEASE ); \
		return false;,
		UNABLE_TO_ALLOCATE_REMOTE_MEMORY );

	return true;
}


bool hookAttach( HANDLE hProcess, wchar_t* libName, char* procName, void* localHookProc, sHook& rHook )
{
	BOOL writeResult = FALSE;
	wchar_t cmd[32] = { 0 };
	DWORD codeLen = 0;
	wchar_t assemblyError[TEXTLEN] = { 0 };

	// Copy the hook function into the target process
	writeResult = WriteProcessMemory( hProcess, rHook.remoteHookProc, localHookProc, rHook.hookSize, NULL );
	PLUGIN_CHECK_ERROR( writeResult, return false;, UNABLE_TO_WRITE_MEMORY_AT, rHook.remoteHookProc );

	// Assemble an unconditional jump to the hook function
	BYTE jmpToHookFunc[UNCONDITIONAL_JMP_SIZE] = { 0 };
	wsprintf( cmd, L"jmp 0x%08X", rHook.remoteHookProc );
	codeLen = Assemble( cmd, (DWORD)rHook.remoteTargetProc, jmpToHookFunc, UNCONDITIONAL_JMP_SIZE, 0, assemblyError );
	PLUGIN_CHECK_ERROR( codeLen, return false;, UNABLE_TO_ASSEMBLE_CODE, cmd, rHook.remoteHookProc, assemblyError );

	// Copy this unconditional jump into target API function
	writeResult = WriteProcessMemory( hProcess, rHook.remoteTargetProc, jmpToHookFunc, UNCONDITIONAL_JMP_SIZE, NULL );
	PLUGIN_CHECK_ERROR( writeResult, return false;, UNABLE_TO_WRITE_MEMORY_AT, rHook.remoteTargetProc );

	return true;
}


bool hookFree( HANDLE hProcess, wchar_t* libName, char* procName, sHook& rHook )
{
	BOOL readResult = FALSE;
	BOOL writeResult = FALSE;
	BOOL freeResult = FALSE;

	// Get API address
	FARPROC procAddressToPatch = hookGetProcAddress( hProcess, libName, procName );
	if( !procAddressToPatch )
		return false;

	if( rHook.trampolineProcSize &&
		rHook.trampolineProc )
	{
		void* localTrampolineProc = new BYTE[rHook.trampolineProcSize];
		PLUGIN_CHECK_ERROR( localTrampolineProc, return false;, UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

		// Copy the trampoline to a local buffer
		readResult = ReadProcessMemory( hProcess, rHook.trampolineProc, localTrampolineProc, rHook.trampolineProcSize, NULL );
		PLUGIN_CHECK_ERROR( readResult,
			delete [] localTrampolineProc; \
			return false;,
			UNABLE_TO_READ_MEMORY_AT, rHook.trampolineProc );

		// Copy the saved trampoline instructions back to target API function
		writeResult = WriteProcessMemory( hProcess, procAddressToPatch, localTrampolineProc, UNCONDITIONAL_JMP_SIZE, NULL );
		PLUGIN_CHECK_ERROR( writeResult,
			delete [] localTrampolineProc; \
			return false;,
			UNABLE_TO_WRITE_MEMORY_AT, procAddressToPatch );

		delete [] localTrampolineProc;
		localTrampolineProc = NULL;
	}

	// Free hook proc
	if( rHook.remoteHookProc )
	{
		freeResult = VirtualFreeEx( hProcess, rHook.remoteHookProc, 0, MEM_RELEASE );
		PLUGIN_CHECK_ERROR( freeResult, return false;, UNABLE_TO_FREE_REMOTE_MEMORY, rHook.remoteHookProc );
	}

	// Free trampoline proc
	if( rHook.trampolineProc )
	{
		freeResult = VirtualFreeEx( hProcess, rHook.trampolineProc, 0, MEM_RELEASE );
		PLUGIN_CHECK_ERROR( freeResult, return false;, UNABLE_TO_FREE_REMOTE_MEMORY, rHook.trampolineProc );
	}

	return true;
}
