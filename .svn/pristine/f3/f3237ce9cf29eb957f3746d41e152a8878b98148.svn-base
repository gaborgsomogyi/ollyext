#include "stdafx.h"
#include "OllyExtAssembler.h"
#include "OllyExtLocal.h"
#include "OllyExtRemote.h"


void* remoteAlloc( HANDLE hProcess, DWORD size )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	void* remoteAddress = VirtualAllocEx( hProcess, NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
	PLUGIN_CHECK_ERROR( remoteAddress, return NULL;, UNABLE_TO_ALLOCATE_REMOTE_MEMORY );

	return remoteAddress;
}


void remoteFree( HANDLE hProcess, void* remoteAddress )
{
	PLUGIN_CHECK_ERROR( hProcess, return;, INVALID_PROCESS_ID );

	BOOL freeResult = VirtualFreeEx( hProcess, remoteAddress, 0, MEM_RELEASE );
	PLUGIN_CHECK_ERROR( freeResult, return;, UNABLE_TO_FREE_REMOTE_MEMORY, remoteAddress );
}


bool remoteRead( HANDLE hProcess, void* remoteAddress, DWORD remoteSize, void* localAddress )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	DWORD oldProtect = 0;
	BOOL protectResult = VirtualProtectEx( hProcess, remoteAddress, remoteSize, PAGE_EXECUTE_READWRITE, &oldProtect );
	PLUGIN_CHECK_ERROR( protectResult, return false;, UNABLE_TO_CHANGE_PROTECTION_AT, remoteAddress );

	BOOL readResult = ReadProcessMemory( hProcess, remoteAddress, localAddress, remoteSize, NULL );
	PLUGIN_CHECK_ERROR( readResult, return false;, UNABLE_TO_READ_MEMORY_AT, remoteAddress );

	protectResult = VirtualProtectEx( hProcess, remoteAddress, remoteSize, oldProtect, &oldProtect );
	PLUGIN_CHECK_ERROR( protectResult, return false;, UNABLE_TO_RESTORE_PROTECTION_AT, remoteAddress );

	return true;
}


bool remoteWrite( HANDLE hProcess, const void* localAddress, DWORD localSize, void* remoteAddress )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	DWORD oldProtect = 0;
	BOOL protectResult = VirtualProtectEx( hProcess, remoteAddress, localSize, PAGE_EXECUTE_READWRITE, &oldProtect );
	PLUGIN_CHECK_ERROR( protectResult, return false;, UNABLE_TO_CHANGE_PROTECTION_AT, remoteAddress );

	BOOL writeResult = WriteProcessMemory( hProcess, remoteAddress, localAddress, localSize, NULL );
	PLUGIN_CHECK_ERROR( writeResult, return false;, UNABLE_TO_WRITE_MEMORY_AT, remoteAddress );

	protectResult = VirtualProtectEx( hProcess, remoteAddress, localSize, oldProtect, &oldProtect );
	PLUGIN_CHECK_ERROR( protectResult, return false;, UNABLE_TO_RESTORE_PROTECTION_AT, remoteAddress );

	return true;
}


bool remoteExec( HANDLE hProcess, void* remoteParamAddress, void* remoteCodeAddress )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	HANDLE hThread = CreateRemoteThread
						(
							hProcess,
							NULL,
							0,
							(LPTHREAD_START_ROUTINE)remoteCodeAddress,
							remoteParamAddress,
							0,
							NULL
						);
	PLUGIN_CHECK_ERROR( hThread, return false;, UNABLE_TO_EXECUTE_REMOTE_THREAD );

	WaitForSingleObject( hThread, INFINITE );
	CloseHandle( hThread );

	return true;
}


FARPROC remoteGetProcAddress( HANDLE hProcess, wchar_t* libName, char* procName )
{
	PLUGIN_CHECK_ERROR( hProcess, return NULL;, INVALID_PROCESS_ID );

	HMODULE hModule = localLoadLibrary( libName );
	if( !hModule ) return NULL;

	MODULEINFO modInfo = { 0 };
	BOOL moduleResult = GetModuleInformation( hProcess, hModule, &modInfo, sizeof( MODULEINFO ) );
	PLUGIN_CHECK_ERROR( moduleResult, return NULL;, UNABLE_TO_GET_REMOTE_MODULE_INFO, libName );

	FARPROC localProcAddress = localGetProcAddress( libName, procName );
	if( !localProcAddress ) return NULL;

	FARPROC remoteProcAddress = localProcAddress;
	if( (DWORD)modInfo.lpBaseOfDll < (DWORD)hModule )
	{
		remoteProcAddress = (FARPROC)( (DWORD)remoteProcAddress - ( (DWORD)hModule - (DWORD)modInfo.lpBaseOfDll ) );
	}
	else if( (DWORD)modInfo.lpBaseOfDll > (DWORD)hModule )
	{
		remoteProcAddress = (FARPROC)( (DWORD)remoteProcAddress + ( (DWORD)modInfo.lpBaseOfDll - (DWORD)hModule ) );
	}

	return remoteProcAddress;
}


bool remotePatchApply( HANDLE hProcess, void* remoteAddress, BYTE* origCode, BYTE* patchCode, DWORD size )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	if( origCode )
	{
		bool readSuccess = remoteRead( hProcess, remoteAddress, size, origCode );
		if( !readSuccess ) return false;
	}

	bool writeSuccess = remoteWrite( hProcess, patchCode, size, remoteAddress );
	if( !writeSuccess ) return false;

	return true;
}


bool remotePatchApply( HANDLE hProcess, wchar_t* libName, char* procName, BYTE* origCode, BYTE* patchCode, DWORD size )
{
	PLUGIN_CHECK_ERROR( hProcess, return false;, INVALID_PROCESS_ID );

	FARPROC procAddress = remoteGetProcAddress( hProcess, libName, procName );
	if( !procAddress ) return false;

	return remotePatchApply( hProcess, (void*)procAddress, origCode, patchCode, size );
}


/*
#define GET_PROC_ADDRESS_CODE_SIZE ( 0x100 )


typedef struct
{
	void* libName;
	void* procName;
	void* result;
} sGetProcAddressParams;

typedef struct
{
	void* procAddress;
} sGetProcAddressResult;


#define ASSEMBLER_ERROR_HANDLER() \
	if( localResultAddress ) \
	{ \
		delete [] localResultAddress; \
	} \
	if( remoteResultAddress ) \
	{ \
		remoteFree( hProcess, remoteResultAddress ); \
	} \
	if( localCodeAddress ) \
	{ \
		delete [] localCodeAddress; \
	} \
	if( remoteCodeAddress ) \
	{ \
		remoteFree( hProcess, remoteCodeAddress ); \
	} \
	if( localParamAddress ) \
	{ \
		delete [] localParamAddress; \
	} \
	if( remoteParamAddress ) \
	{ \
		remoteFree( hProcess, remoteParamAddress ); \
	} \
	return NULL;

FARPROC remoteGetProcAddress( HANDLE hProcess, wchar_t* libName, char* procName )
{
	PLUGIN_CHECK_ERROR( hProcess, return NULL;, INVALID_PROCESS_ID );

	wchar_t cmd[64] = { 0 };
	DWORD localEip = 0;
	DWORD patchEip = 0;
	DWORD labelEip = 0;

	void* remoteParamAddress = NULL;
	void* localParamAddress = NULL;
	void* remoteCodeAddress = NULL;
	void* localCodeAddress = NULL;
	void* remoteResultAddress = NULL;
	void* localResultAddress = NULL;

	// Prepare params
	remoteParamAddress = remoteAlloc( hProcess, GET_PROC_ADDRESS_CODE_SIZE );
	if( !remoteParamAddress ) return NULL;

	DWORD localParamSize = ( wcslen( libName ) << 1 ) + 2 + strlen( procName ) + 1 + sizeof( sGetProcAddressParams );
	localParamAddress = new BYTE[localParamSize];
	PLUGIN_CHECK_ERROR( localParamAddress,
		remoteFree( hProcess, remoteParamAddress ); \
		return NULL;,
		UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

	ASSEMBLER_FLUSH();
	ASSEMBLER_SET_CODEBASE( (DWORD)remoteParamAddress );
	ASSEMBLER_SET_TARGET_BUFFER( (BYTE*)localParamAddress );

	sGetProcAddressParams* pParams = (sGetProcAddressParams*)localParamAddress;
	localEip += sizeof( sGetProcAddressParams );
	pParams->libName = (void*)( (DWORD)remoteParamAddress + localEip );
	ASSEMBLER_ADD_WSTRING_AND_STEP( libName, localEip );
	pParams->procName = (void*)( (DWORD)remoteParamAddress + localEip );
	ASSEMBLER_ADD_STRING_AND_STEP( procName, localEip );
	
	// Prepare code
	remoteCodeAddress = remoteAlloc( hProcess, GET_PROC_ADDRESS_CODE_SIZE );
	if( !remoteCodeAddress )
	{
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}

	localCodeAddress = new BYTE[GET_PROC_ADDRESS_CODE_SIZE];
	PLUGIN_CHECK_ERROR( localCodeAddress,
		remoteFree( hProcess, remoteCodeAddress ); \
		delete [] localParamAddress; \
		remoteFree( hProcess, remoteParamAddress ); \
		return NULL;,
		UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

	localEip = 0;
	ASSEMBLER_FLUSH();
	ASSEMBLER_SET_CODEBASE( (DWORD)remoteCodeAddress );
	ASSEMBLER_SET_TARGET_BUFFER( (BYTE*)localCodeAddress );

	ASSEMBLE_AND_STEP( L"mov edx, dword ptr[esp + 0x04]", localEip );
	ASSEMBLE_AND_STEP( L"push dword ptr[edx]", localEip );
	FARPROC loadLibraryW = localGetProcAddress( L"kernel32.dll", "LoadLibraryW" );
	if( !loadLibraryW )
	{
		delete [] localCodeAddress;
		remoteFree( hProcess, remoteCodeAddress );
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}
	wsprintf( cmd, L"call 0x%08X", loadLibraryW );
	ASSEMBLE_AND_STEP( cmd, localEip );
	ASSEMBLE_AND_STEP( L"mov edx, dword ptr[esp + 0x04]", localEip );
	ASSEMBLE_AND_STEP( L"push dword ptr[edx + 0x04]", localEip );
	ASSEMBLE_AND_STEP( L"push eax", localEip );
	FARPROC getProcAddress = localGetProcAddress( L"kernel32.dll", "GetProcAddress" );
	if( !getProcAddress )
	{
		delete [] localCodeAddress;
		remoteFree( hProcess, remoteCodeAddress );
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}
	wsprintf( cmd, L"call 0x%08X", getProcAddress );
	ASSEMBLE_AND_STEP( cmd, localEip );
	ASSEMBLE_AND_STEP( L"mov edx, dword ptr[esp + 0x04]", localEip );
	ASSEMBLE_AND_STEP( L"mov ebx, dword ptr[edx + 0x08]", localEip );
	ASSEMBLE_AND_STEP( L"mov dword ptr[ebx], eax", localEip );
	ASSEMBLE_AND_STEP( L"xor eax, eax", localEip );
	ASSEMBLE_AND_STEP( L"ret 0x04", localEip );

	// Prepare result
	remoteResultAddress = remoteAlloc( hProcess, sizeof( sGetProcAddressResult ) );
	if( !remoteResultAddress )
	{
		delete [] localCodeAddress;
		remoteFree( hProcess, remoteCodeAddress );
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}

	DWORD localResultSize = sizeof( sGetProcAddressResult );
	localResultAddress = new BYTE[localResultSize];
	PLUGIN_CHECK_ERROR( localResultAddress,
		remoteFree( hProcess, remoteResultAddress ); \
		delete [] localCodeAddress; \
		remoteFree( hProcess, remoteCodeAddress ); \
		delete [] localParamAddress; \
		remoteFree( hProcess, remoteParamAddress ); \
		return NULL;,
		UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

	pParams->result = remoteResultAddress;

	// Transfer params
	bool writeResult = remoteWrite( hProcess, localParamAddress, localParamSize, remoteParamAddress );
	if( !writeResult )
	{
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}

	// Transfer code
	writeResult = remoteWrite( hProcess, localCodeAddress, GET_PROC_ADDRESS_CODE_SIZE, remoteCodeAddress );
	if( !writeResult )
	{
		delete [] localCodeAddress;
		remoteFree( hProcess, remoteCodeAddress );
		delete [] localParamAddress;
		remoteFree( hProcess, remoteParamAddress );
		return NULL;
	}

	// Execute it
	bool execResult = remoteExec( hProcess, remoteParamAddress, remoteCodeAddress );
	FARPROC remoteProcAddress = 0;
	if( execResult )
	{
		bool readResult = remoteRead( hProcess, remoteResultAddress, localResultSize, localResultAddress );
		if( readResult )
		{
			remoteProcAddress = (FARPROC)((sGetProcAddressResult*)localResultSize)->procAddress;
		}
	}

	ASSEMBLER_FLUSH();
	delete [] localResultAddress;
	remoteFree( hProcess, remoteResultAddress );
	delete [] localCodeAddress;
	remoteFree( hProcess, remoteCodeAddress );
	delete [] localParamAddress;
	remoteFree( hProcess, remoteParamAddress );

	return remoteProcAddress;
}*/
