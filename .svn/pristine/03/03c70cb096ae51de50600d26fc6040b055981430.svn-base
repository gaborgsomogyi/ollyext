#include "stdafx.h"
#include "OllyExtRip.h"
#include "OllyExtDataRip.h"
#include "OllyExtGeneral.h"


static bool dataRipGetDataFromRange( std::string& rCode )
{
	rCode = "";

	t_dump* pDataDump = Getcpudisasmdump();
	PLUGIN_CHECK_ERROR( pDataDump, return false;, UNABLE_TO_GET_DISASSEMBLER_DUMP );

	DWORD bufferSize = pDataDump->sel1 - pDataDump->sel0;

	PLUGIN_CHECK_ERROR_NO_MB( pDataDump->sel0 && bufferSize, return false; );

	// Allocate the necessary memory
	BYTE* pBuffer = new BYTE[bufferSize];
	PLUGIN_CHECK_ERROR( pBuffer, return false;, UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

	// Read the assembly from the target binary
	PLUGIN_CHECK_ERROR( Readmemory( pBuffer, pDataDump->sel0, bufferSize, MM_SILENT ),
		delete [] pBuffer;
		return false;,
		UNABLE_TO_READ_REMOTE_PROCESS_MEMORY, pDataDump->sel0, bufferSize );

	switch( g_generalOptions.codeRipperSyntax )
	{
	default:
	case DATA_CSYNTAX:
		rCode += "static unsigned char g_data[] =\n{\n";
	break;

	case DATA_MASMSYNTAX:
		rCode += "g_data\\\n";
	break;
	}

	char numStr[16] = { 0 };
	for( DWORD i = 0; i < bufferSize; ++i )
	{
		sprintf_s( numStr, sizeof( numStr ), "0x%02X, ", pBuffer[i] );
		rCode += numStr;
	}

	switch( g_generalOptions.codeRipperSyntax )
	{
	default:
	case DATA_CSYNTAX:
		rCode += "\n};\n";
	break;

	case DATA_MASMSYNTAX:
		// Nothing to do
	break;
	}

	// Remove buffer
	delete [] pBuffer;

	return true;
}


void dataRipExecute( void )
{
	std::string dataStr = "";

	PLUGIN_CHECK_ERROR_NO_MB( dataRipGetDataFromRange( dataStr ), return; );
	PLUGIN_CHECK_ERROR_NO_MB( ripSendToClipboard( dataStr ), return; );

	Addtolist( 0, BLACK, L"OllyExt: Data ripped successfully" );
}
