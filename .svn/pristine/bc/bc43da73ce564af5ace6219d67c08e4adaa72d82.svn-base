#include "stdafx.h"
#include "CheckRemoteDebuggerPresent.h"


#define LIBNAME ( L"ntdll.dll" )
#define PROCNAME ( "NtQueryInformationProcess" )


typedef NTSTATUS ( WINAPI* NTQUERYINFORMATIONPROCESS )
(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
);

static bool g_applied = false;
static NTQUERYINFORMATIONPROCESS NtQueryInformationProcessTrampoline = NULL;


NTSTATUS WINAPI NtQueryInformationProcessHook
(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
)
{
	Addtolist( 0, BLACK, L"%d", ProcessInformationClass );

	return NtQueryInformationProcessTrampoline
			(
				ProcessHandle,
				ProcessInformationClass,
				ProcessInformation,
				ProcessInformationLength,
				ReturnLength
			);
}


void checkRemoteDebuggerPresentReset( void )
{
	g_applied = false;
}


void checkRemoteDebuggerPresentApply( bool protect )
{
	if( protect )
	{
		if( g_applied ) return;

		HMODULE module = LoadLibrary( LIBNAME );
		PLUGIN_CHECK_ERROR( module, return;, UNABLE_TO_FIND_MODULE, LIBNAME );

		FARPROC procAddressToPatch = GetProcAddress( module, PROCNAME );
		if( !procAddressToPatch )
		{
			wchar_t procNameW[TEXTLEN];
			Asciitounicode( PROCNAME, strlen( PROCNAME ), procNameW, TEXTLEN );
			PLUGIN_CHECK_ERROR( FALSE, return;, UNABLE_TO_FIND_FUNCTION, LIBNAME, procNameW );
		}
		NtQueryInformationProcessTrampoline = (NTQUERYINFORMATIONPROCESS)procAddressToPatch;

/*		LONG beginResult = DetourTransactionBegin();
		PLUGIN_CHECK_ERROR( beginResult == NO_ERROR, return;, UNABLE_TO_START_DETOURS_TRANSACTION, beginResult );

		LONG updateThreadResult = DetourUpdateThread( GetCurrentThread() );
		PLUGIN_CHECK_ERROR( updateThreadResult == NO_ERROR, return;, UNABLE_TO_UPDATE_DETOURS_THREAD, updateThreadResult );

		LONG attachResult = DetourAttach( &(PVOID&)NtQueryInformationProcessTrampoline, NtQueryInformationProcessHook );
		PLUGIN_CHECK_ERROR( attachResult == NO_ERROR, return;, UNABLE_TO_ATTACH_DETOURS, NtQueryInformationProcessTrampoline, attachResult );

		LONG commitResult = DetourTransactionCommit();
		PLUGIN_CHECK_ERROR( commitResult == NO_ERROR, return;, UNABLE_TO_COMMIT_DETOURS_TRANSACTION, commitResult );*/

		g_applied = true;
	}
	else
	{
		if( !g_applied ) return;

/*		LONG beginResult = DetourTransactionBegin();
		PLUGIN_CHECK_ERROR( beginResult == NO_ERROR, return;, UNABLE_TO_START_DETOURS_TRANSACTION, beginResult );

		LONG updateThreadResult = DetourUpdateThread( GetCurrentThread() );
		PLUGIN_CHECK_ERROR( updateThreadResult == NO_ERROR, return;, UNABLE_TO_UPDATE_DETOURS_THREAD, updateThreadResult );

		LONG detachResult = DetourDetach( &(PVOID&)NtQueryInformationProcessTrampoline, NtQueryInformationProcessHook );
		PLUGIN_CHECK_ERROR( detachResult == NO_ERROR, return;, UNABLE_TO_DETACH_DETOURS, NtQueryInformationProcessTrampoline, detachResult );

		LONG commitResult = DetourTransactionCommit();
		PLUGIN_CHECK_ERROR( commitResult == NO_ERROR, return;, UNABLE_TO_COMMIT_DETOURS_TRANSACTION, commitResult );*/

		g_applied = false;
	}
}
