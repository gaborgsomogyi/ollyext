#include "stdafx.h"
#include "plugin.h"
#include "OllyExt.h"
#include "OllyExtProtect.h"

#include "IsDebuggerPresent.h"
#include "NtGlobalFlag.h"
#include "HeapFlags.h"
#include "ForceFlags.h"


sProtectOptions g_protectOptions = { 0 };


#define ISDEBUGGERPRESENT L"IsDebuggerPresent"
#define NTGLOBALFLAG L"NtGlobalFlag"
#define HEAPFLAGS L"HeapFlags"
#define FORCEFLAGS L"ForceFlags"

#define GETFROMINI( feature, option ) \
{ \
	DWORD data = 0; \
	Getfromini( NULL, PLUGIN_NAME, feature, L"%d", &data );\
	option = ( data != 0 ); \
}


void protectReadOptions( void )
{
	GETFROMINI( ISDEBUGGERPRESENT, g_protectOptions.isDebuggerPresent );
	GETFROMINI( NTGLOBALFLAG, g_protectOptions.ntGlobalFlag );
	GETFROMINI( HEAPFLAGS, g_protectOptions.heapFlags );
	GETFROMINI( FORCEFLAGS, g_protectOptions.forceFlags );
}


void protectWriteOptions( void )
{
	Writetoini( NULL, PLUGIN_NAME, ISDEBUGGERPRESENT, L"%d", g_protectOptions.isDebuggerPresent );
	Writetoini( NULL, PLUGIN_NAME, NTGLOBALFLAG, L"%d", g_protectOptions.ntGlobalFlag );
	Writetoini( NULL, PLUGIN_NAME, HEAPFLAGS, L"%d", g_protectOptions.heapFlags );
	Writetoini( NULL, PLUGIN_NAME, FORCEFLAGS, L"%d", g_protectOptions.forceFlags );
}


void protectReset( void )
{
	isDebuggerPresentReset();
	ntGlobalFlagReset();
	heapFlagsReset();
	forceFlagsReset();
}


bool protectApply( void )
{
	PLUGIN_CHECK_ERROR( process, return false, NO_DEBUGGE );

	isDebuggerPresentApply( g_protectOptions.isDebuggerPresent );
	ntGlobalFlagApply( g_protectOptions.ntGlobalFlag );
	heapFlagsApply( g_protectOptions.heapFlags );
	forceFlagsApply( g_protectOptions.forceFlags );

	return true;
}


bool protectApplyPatch( void* address, BYTE* orig, BYTE* patch, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, NO_DEBUGGE );

	BOOL readSuccess = ReadProcessMemory( process, address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( readSuccess, return false, UNABLE_TO_READ_MEMORY_AT, address );

	BOOL writeSuccess = WriteProcessMemory( process, address, patch, size, NULL );
	PLUGIN_CHECK_ERROR( writeSuccess, return false, UNABLE_TO_WRITE_MEMORY_AT, address );

	return true;
}


bool protectApplyPatch( wchar_t* libName, char* procName, BYTE* orig, BYTE* patch, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, NO_DEBUGGE );

	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return false, UNABLE_TO_FIND_MODULE, libName );

	FARPROC address = GetProcAddress( module, procName );
	if( !address )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return false, UNABLE_TO_FIND_FUNCTION, libName, procNameW );
	}

	return protectApplyPatch( (void*)address, orig, patch, size );
}


bool protectRevertPatch( void* address, BYTE* orig, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, NO_DEBUGGE );

	BOOL success = WriteProcessMemory( process, address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( success, return false, UNABLE_TO_WRITE_MEMORY_AT, address );

	return true;
}


bool protectRevertPatch( wchar_t* libName, char* procName, BYTE* orig, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, NO_DEBUGGE );

	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return false, UNABLE_TO_FIND_MODULE, libName );

	FARPROC address = GetProcAddress( module, procName );
	if( !address )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return false, UNABLE_TO_FIND_FUNCTION, libName, procNameW );
	}

	return protectRevertPatch( (void*)address, orig, size );
}
