#include "StdAfx.h"
#include "beaengine\BeaEngine.h"
#include "multiCpu.h"
#include "INTHelper.h"
#include "INT0D.h"
#include "RDTSC.h"


void RDTSCEnableDPC( IN struct _KDPC *Dpc, IN PVOID DeferredContext, IN void* SystemArgument1, IN void* SystemArgument2 );
void RDTSCDisableDPC( IN struct _KDPC *Dpc, IN PVOID DeferredContext, IN void* SystemArgument1, IN void* SystemArgument2 );
bool __stdcall int0DHandler( ULONG originalESP );


static bool g_protected = false;
ULONG g_edx = 0;
ULONG g_eax = 0;


void RDTSCInit( void )
{
	int0DAddHook( int0DHandler );
	mcpuExec( RDTSCDisableDPC, NULL );
}


void RDTSCClean( void )
{
	mcpuExec( RDTSCEnableDPC, NULL );
}


void RDTSCProtect( void )
{
	g_protected = true;
}


void RDTSCUnprotect( void )
{
	g_protected = false;
}


void RDTSCEnableDPC( IN struct _KDPC *Dpc, IN void* DeferredContext, IN void* SystemArgument1, IN void* SystemArgument2 )
{
	RDTSCEnable();

	LONG* numberOfDoneCPU = (LONG*)SystemArgument1;
	if( numberOfDoneCPU ) InterlockedIncrement( numberOfDoneCPU );
}


VOID RDTSCDisableDPC( IN struct _KDPC *Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2 )
{
	RDTSCDisable();

	LONG* numberOfDoneCPU = (LONG*)SystemArgument1;
	if( numberOfDoneCPU ) InterlockedIncrement( numberOfDoneCPU );
}


bool __stdcall int0DHandler( ULONG originalESP )
{
	STACK_WITHERRCONTEXT* pStack = (STACK_WITHERRCONTEXT*)originalESP;

	__try
	{
		DISASM d = { 0 };
		d.EIP = pStack->intStack.eip;
		int len = Disasm( &d );
		if( len != UNKNOWN_OPCODE )
		{
			// rdtsc opcode
			if( d.Instruction.Opcode == 0x00000F31 )
			{
				if( g_protected )
				{
					pStack->context.edx = g_edx;
					pStack->context.eax = g_eax;
					if( !++g_eax ) ++g_edx;
				}
				else
				{
					rdtscCmd( &pStack->context.edx, &pStack->context.eax );
				}
			}

			pStack->intStack.eip += len;
			return true;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return false;
}
