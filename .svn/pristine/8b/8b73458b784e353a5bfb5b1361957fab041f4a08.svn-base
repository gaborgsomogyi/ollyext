#pragma once


extern std::hash_map<std::string, DWORD> g_asmMarkers;
extern std::hash_map<std::string, DWORD> g_asmLabels;
extern DWORD g_asmCodeBase;
extern BYTE* g_asmBuffer;


#define ASSEMBLER_FLUSH() \
	g_asmMarkers.clear(); \
	g_asmLabels.clear();

#define ASSEMBLER_SET_CODEBASE( asmCodeBase ) \
	g_asmCodeBase = asmCodeBase;

#define ASSEMBLER_SET_TARGET_BUFFER( buffer ) \
	g_asmBuffer = buffer;

#define ASSEMBLER_SET_MARKER( name, localEip ) \
	g_asmMarkers[name] = localEip;

#define ASSEMBLER_GET_MARKER( name ) \
	g_asmMarkers[name];

#define ASSEMBLER_SET_LABEL( name, localEip ) \
	g_asmLabels[name] = localEip;

#define ASSEMBLER_GET_LABEL( name ) \
	g_asmLabels[name];

#define ASSEMBLE( cmd, localEip ) \
{ \
	DWORD codeLen = 0; \
	wchar_t assemblyError[TEXTLEN] = { 0 }; \
	codeLen = Assemble( cmd, g_asmCodeBase + localEip, &g_asmBuffer[localEip], MAXCMDSIZE, 0, assemblyError ); \
	PLUGIN_CHECK_ERROR( codeLen, \
		ASSEMBLER_ERROR_HANDLER(), \
		UNABLE_TO_ASSEMBLE_CODE, cmd, g_asmCodeBase + localEip, assemblyError ); \
}

#define ASSEMBLE_AND_STEP( cmd, localEip ) \
{ \
	DWORD codeLen = 0; \
	wchar_t assemblyError[TEXTLEN] = { 0 }; \
	codeLen = Assemble( cmd, g_asmCodeBase + localEip, &g_asmBuffer[localEip], MAXCMDSIZE, 0, assemblyError ); \
	PLUGIN_CHECK_ERROR( codeLen, \
		ASSEMBLER_ERROR_HANDLER(), \
		UNABLE_TO_ASSEMBLE_CODE, cmd, g_asmCodeBase + localEip, assemblyError ); \
	localEip += codeLen; \
}
