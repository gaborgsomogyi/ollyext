#include "stdafx.h"
#include <fstream>
#include <hash_map>
#include "Core/vlx.h"
#include "Core/Log.h"
#include "Core/Ini.h"
#include "Core/Remote.h"
#include "Custom.h"


#define CUSTOM_DEBUG
#define CUSTOM_PATCH_DIRECTORY ( L"OllyExtPatches" )
#define CUSTOM_PATCH_FIND_PATTERN ( L"OllyExtPatches/*.ini" )


static std::hash_map<std::wstring, bool> g_applied;


static bool dirExists( const wchar_t* dirName )
{
	DWORD attr = GetFileAttributes( dirName );
	if( attr == INVALID_FILE_ATTRIBUTES )
		return false;

	return ( attr & FILE_ATTRIBUTE_DIRECTORY ) != 0;
}


static bool resourceSave( HMODULE hMod, DWORD resourceID, const wchar_t* resourceType, const wchar_t* fileName )
{
	logMessage( L"%ws: Saving resource: %ws", dbgGetPluginName(), fileName );

	HRSRC res = FindResource( hMod, MAKEINTRESOURCE( resourceID ), resourceType );
	PLUGIN_CHECK_ERROR( res, return false;, UNABLE_TO_FIND_RESOURCE );

	unsigned int resSize = SizeofResource( hMod, res );
	PLUGIN_CHECK_ERROR( resSize, return false;, UNABLE_TO_GET_RESOURCE_SIZE );

	HGLOBAL resData = LoadResource( hMod, res );
	PLUGIN_CHECK_ERROR( resData, return false;, UNABLE_TO_LOAD_RESOURCE );

	void* resBinaryData = LockResource( resData );
	PLUGIN_CHECK_ERROR( resBinaryData, return false;, UNABLE_TO_LOCK_RESOURCE );

	void* resBinaryDataUnpacked = NULL;
	unsigned int resSizeUnpacked = 0;
	bool isUnpacked = vlx_decompress( resBinaryData, resSize, &resBinaryDataUnpacked, (DWORD*)&resSizeUnpacked );
	PLUGIN_CHECK_ERROR( isUnpacked, return false;, UNABLE_TO_UNCOMPRESS_DATA );

    std::ofstream f( fileName, std::ios::out | std::ios::binary );
	PLUGIN_CHECK_ERROR( !f.fail(),
		if( resBinaryDataUnpacked )\
		{\
			delete [] resBinaryDataUnpacked;\
			resBinaryDataUnpacked = NULL;\
		}\
		return false;,
		UNABLE_TO_SAVE_FILE_BECAUSE_OF_FAILBIT );
	PLUGIN_CHECK_ERROR( !f.bad(),
		if( resBinaryDataUnpacked )\
		{\
			delete [] resBinaryDataUnpacked;\
			resBinaryDataUnpacked = NULL;\
		}\
		return false;,
		UNABLE_TO_SAVE_FILE_BECAUSE_OF_BADBIT );
    f.write( (char*)resBinaryDataUnpacked, resSizeUnpacked );
	PLUGIN_CHECK_ERROR( !f.fail(),
		if( resBinaryDataUnpacked )\
		{\
			delete [] resBinaryDataUnpacked;\
			resBinaryDataUnpacked = NULL;\
		}\
		return false;,
		UNABLE_TO_SAVE_FILE_BECAUSE_OF_FAILBIT );
	PLUGIN_CHECK_ERROR( !f.bad(),
		if( resBinaryDataUnpacked )\
		{\
			delete [] resBinaryDataUnpacked;\
			resBinaryDataUnpacked = NULL;\
		}\
		return false;,
		UNABLE_TO_SAVE_FILE_BECAUSE_OF_BADBIT );
    f.close();

	if( resBinaryDataUnpacked )
	{
		delete [] resBinaryDataUnpacked;
		resBinaryDataUnpacked = NULL;
	}

	return true;
}


void customInit( HMODULE hMod )
{
	if( !dirExists( CUSTOM_PATCH_DIRECTORY ) )
	{
		CreateDirectory( CUSTOM_PATCH_DIRECTORY, NULL );
		resourceSave( hMod, IDR_INI_FILE1, L"INI_FILE", L"OllyExtPatches\\Example.ini" );
	}
}


void customReset( void )
{
	g_applied.clear();
}


bool customApply( bool enabled )
{
	if( !enabled ) return true;

	WIN32_FIND_DATA findData;
	HANDLE hFind = FindFirstFile( CUSTOM_PATCH_FIND_PATTERN, &findData );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do
		{
			if( g_applied[findData.cFileName] ) continue;

#ifdef CUSTOM_DEBUG
			logMessage( L"%ws: Applying custom patch: %ws", dbgGetPluginName(), findData.cFileName );
#endif
			std::wstring iniFilePath = L".\\";
			iniFilePath.append( CUSTOM_PATCH_DIRECTORY );
			iniFilePath.append( L"\\" );
			iniFilePath.append( findData.cFileName );

			std::wstring patchName = iniReadString( iniFilePath.c_str(), L"Name" );
			std::wstring moduleName = iniReadString( iniFilePath.c_str(), L"Module" );
			std::wstring functionName = iniReadString( iniFilePath.c_str(), L"Function" );
			std::wstring patch = iniReadString( iniFilePath.c_str(), L"Patch" );

#ifdef CUSTOM_DEBUG
			logMessage( L"%ws:   Name: %ws", dbgGetPluginName(), patchName.c_str() );
			logMessage( L"%ws:   Module: %ws", dbgGetPluginName(), moduleName.c_str() );
			logMessage( L"%ws:   Function: %ws", dbgGetPluginName(), functionName.c_str() );
			logMessage( L"%ws:   Patch: %ws", dbgGetPluginName(), patch.c_str() );
#endif

			FARPROC procAddress = remoteGetProcAddress( dbgGetProcessHandle(), moduleName.c_str(), functionName.c_str() );
			if( !procAddress ) continue;

			DWORD patchSize = patch.length() >> 1;
			if( !patchSize ) continue;
			BYTE* patchCode = new BYTE[patchSize];
			memset( patchCode, 0, patchSize );

			DWORD ptr = 0;
			for( DWORD i = 0; i < patch.length(); i += 2 )
			{
				std::wstring subPatch = patch.substr( i, 2 );
				swscanf( subPatch.c_str(), L"%02X", &patchCode[ptr++] );
			}

			if( !remotePatchApply( dbgGetProcessHandle(), procAddress, NULL, patchCode, patchSize ) )
			{
				delete [] patchCode;
				continue;
			}

			delete [] patchCode;

#ifdef CUSTOM_DEBUG
			logMessage( L"%ws: Applied custom patch: %ws", dbgGetPluginName(), findData.cFileName );
#endif
			g_applied[findData.cFileName] = true;
		} while( FindNextFile( hFind, &findData ) );
		FindClose( hFind );
	}

	return true;
}
