#include "StdAfx.h"
#include "multiCpu.h"


static LONG g_numberOfDoneCPU = 0;


void mcpuExec( PKDEFERRED_ROUTINE routine, PVOID parameters )
{
	KIRQL CurrentIrql, OldIrql;

	// Raise IRQL here.
	CurrentIrql = KeGetCurrentIrql();
	OldIrql = CurrentIrql;
	if( CurrentIrql < DISPATCH_LEVEL )
		KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );
	CurrentIrql = KeGetCurrentIrql();

	// Allocate room for our DPCs. This must be in NonPagedPool!
	PKDPC pkdpc = (PKDPC)ExAllocatePoolWithTag( NonPagedPool, KeNumberProcessors * sizeof( KDPC ), 0 );
	if( !pkdpc ) return;

	// Initialize globals to zero.
	InterlockedAnd( &g_numberOfDoneCPU, 0 );

	ULONG DCPNum = 0;
	ULONG currentCPU = KeGetCurrentProcessorNumber();
	for( char i = 0; i < KeNumberProcessors; ++i )
	{
		// Make sure we don't schedule a DPC on the current
		// processor. This would cause a deadlock.
		if( i != currentCPU )
		{
			KeInitializeDpc( pkdpc + i, routine, parameters );
			// Set the target processor for the DPC; otherwise,
			// it will be queued on the current processor when
			// we call KeInsertQueueDpc.
			KeSetTargetProcessorDpc( pkdpc + i, i );
			if( KeInsertQueueDpc( pkdpc + i, &g_numberOfDoneCPU, NULL ) )
				++DCPNum;
		}
	}

	while( InterlockedCompareExchange( &g_numberOfDoneCPU, DCPNum, DCPNum ) != DCPNum ) nopCmd();

	ExFreePoolWithTag( pkdpc, 0 );

	routine( NULL, parameters, NULL, NULL );

	if( CurrentIrql > OldIrql ) KeLowerIrql( OldIrql );
}
