#include "stdafx.h"
#include "..\OllyExtHook.h"
#include "CheckRemoteDebuggerPresent.h"


#define ASSEMBLE( cmd, eip, dstAddr ) \
	codeLen = Assemble( cmd, eip, dstAddr, MAXCMDSIZE, 0, assemblyError ); \
	PLUGIN_CHECK_ERROR( codeLen, \
		delete [] localHookProc; \
		hookFree( process, LIBNAME, PROCNAME, g_hook ); \
		return;, \
		UNABLE_TO_ASSEMBLE_CODE, cmd, eip, assemblyError );

#define ASSEMBLE_AND_STEP( cmd, eip, dstAddr ) \
	ASSEMBLE( cmd, eip, dstAddr ); \
	codeEip += codeLen; \
	codePtr += codeLen;

#define LIBNAME ( L"ntdll.dll" )
#define PROCNAME ( "NtQueryInformationProcess" )
#define HOOK_SIZE ( 0x100 )


static bool g_applied = false;
static sHook g_hook = { 0 };


void checkRemoteDebuggerPresentReset( void )
{
	g_applied = false;
}


void checkRemoteDebuggerPresentApply( bool protect )
{
	if( protect )
	{
		if( g_applied ) return;

		wchar_t procNameW[TEXTLEN];
		Asciitounicode( PROCNAME, strlen( PROCNAME ), procNameW, TEXTLEN );

		g_hook.remoteTargetProc = NULL;
		g_hook.trampolineProcSize = 0;
		g_hook.trampolineProc = NULL;
		g_hook.hookSize = HOOK_SIZE;
		g_hook.remoteHookProc = NULL;

		bool allocResult = hookAlloc( process, LIBNAME, PROCNAME, g_hook );
		PLUGIN_CHECK_ERROR( allocResult, return;, UNABLE_TO_ALLOC_HOOK, LIBNAME, procNameW );

		BYTE* localHookProc = new BYTE[HOOK_SIZE];
		PLUGIN_CHECK_ERROR( localHookProc,
			hookFree( process, LIBNAME, PROCNAME, g_hook ); \
			return;,
			UNABLE_TO_ALLOCATE_LOCAL_MEMORY );

		wchar_t cmd[32] = { 0 };
		DWORD codeLen = 0;
		wchar_t assemblyError[TEXTLEN] = { 0 };
		DWORD codePtr = 0;
		DWORD codeEip = (DWORD)g_hook.remoteHookProc;

		// Call original function
		ASSEMBLE_AND_STEP( L"mov eax, esp", codeEip, &localHookProc[codePtr] );
		ASSEMBLE_AND_STEP( L"mov ecx, 0x05", codeEip, &localHookProc[codePtr] );
		DWORD loopEIP = codeEip;
		ASSEMBLE_AND_STEP( L"mov edx, [ecx*4+eax]", codeEip, &localHookProc[codePtr] );
		ASSEMBLE_AND_STEP( L"push edx", codeEip, &localHookProc[codePtr] );
		ASSEMBLE_AND_STEP( L"dec ecx", codeEip, &localHookProc[codePtr] );
		ASSEMBLE_AND_STEP( L"cmp ecx, 0x00", codeEip, &localHookProc[codePtr] );
		wsprintf( cmd, L"jnz 0x%08X", loopEIP );
		ASSEMBLE_AND_STEP( cmd, codeEip, &localHookProc[codePtr] );
		wsprintf( cmd, L"call 0x%08X", g_hook.trampolineProc );
		ASSEMBLE_AND_STEP( cmd, codeEip, &localHookProc[codePtr] );

		// If ProcessInformationClass == 7
		ASSEMBLE_AND_STEP( L"cmp dword ptr[esp + 8], 0x07", codeEip, &localHookProc[codePtr] );
		wsprintf( cmd, L"jnz 0x%08X", codeEip + 12 );
		ASSEMBLE_AND_STEP( cmd, codeEip, &localHookProc[codePtr] );

		// Remove port :)
		ASSEMBLE_AND_STEP( L"mov eax, [esp + 0x0C]", codeEip, &localHookProc[codePtr] );
		ASSEMBLE_AND_STEP( L"mov dword ptr[eax], 0", codeEip, &localHookProc[codePtr] );

		// Return and clean the stack
		ASSEMBLE_AND_STEP( L"ret 0x14", codeEip, &localHookProc[codePtr] );

		bool attachResult = hookAttach( process, LIBNAME, PROCNAME, localHookProc, g_hook );
		PLUGIN_CHECK_ERROR( attachResult,
			delete [] localHookProc; \
			hookFree( process, LIBNAME, PROCNAME, g_hook ); \
			return;,
			UNABLE_TO_ATTACH_HOOK, LIBNAME, procNameW );

		delete [] localHookProc;

		g_applied = true;
	}
	else
	{
		if( !g_applied ) return;

		wchar_t procNameW[TEXTLEN];
		Asciitounicode( PROCNAME, strlen( PROCNAME ), procNameW, TEXTLEN );

		bool freeResult = hookFree( process, LIBNAME, PROCNAME, g_hook );
		PLUGIN_CHECK_ERROR( freeResult, return;, UNABLE_TO_FREE_HOOK, LIBNAME, procNameW );

		g_applied = false;
	}
}
