#include "stdafx.h"
#include "plugin.h"
#include "OllyExt.h"
#include "OllyExtProtect.h"

#include "IsDebuggerPresent.h"


sOptions g_options = { 0 };


#define ISDEBUGGERPRESENT L"isDebuggerPresent"


void protectReadOptions( void )
{
	DWORD data;
	Getfromini( NULL, PLUGIN_NAME, ISDEBUGGERPRESENT, L"%d", &data );
	g_options.isDebuggerPresent = ( data != 0 );
}


void protectWriteOptions( void )
{
	Writetoini( NULL, PLUGIN_NAME, ISDEBUGGERPRESENT, L"%d", g_options.isDebuggerPresent );
}


void protectReset( void )
{
	isDebuggerPresentReset();
}


bool protectApplyPatch( void* address, BYTE* orig, BYTE* patch, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, L"No active debugge found to hook" );

	BOOL readSuccess = ReadProcessMemory( process, address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( readSuccess, return false, L"Unable to read debugge memory at: %08X", address );

	BOOL writeSuccess = WriteProcessMemory( process, address, patch, size, NULL );
	PLUGIN_CHECK_ERROR( writeSuccess, return false, L"Unable to write debugge memory at: %08X", address );

	return true;
}


bool protectApplyPatch( wchar_t* libName, char* procName, BYTE* orig, BYTE* patch, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, L"No active debugge found to hook" );

	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return false, L"Unable to find module: %ws", libName );

	FARPROC address = GetProcAddress( module, procName );
	if( !address )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return false, L"Unable to find function: %ws::%s", libName, procNameW );
	}

	BOOL readSuccess = ReadProcessMemory( process, (void*)address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( readSuccess, return false, L"Unable to read debugge memory at: %08X", address );

	BOOL writeSuccess = WriteProcessMemory( process, (void*)address, patch, size, NULL );
	PLUGIN_CHECK_ERROR( writeSuccess, return false, L"Unable to write debugge memory at: %08X", address );

	return true;
}


bool protectRevertPatch( void* address, BYTE* orig, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, L"No active debugge found to hook" );

	BOOL success = WriteProcessMemory( process, address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( success, return false, L"Unable to write debugge memory at: %08X", address );

	return true;
}


bool protectRevertPatch( wchar_t* libName, char* procName, BYTE* orig, DWORD size )
{
	PLUGIN_CHECK_ERROR( process, return false, L"No active debugge found to hook" );

	HMODULE module = LoadLibrary( libName );
	PLUGIN_CHECK_ERROR( module, return false, L"Unable to find module: %ws", libName );

	FARPROC address = GetProcAddress( module, procName );
	if( !address )
	{
		wchar_t procNameW[TEXTLEN];
		Asciitounicode( procName, strlen( procName ), procNameW, TEXTLEN );
		PLUGIN_CHECK_ERROR( FALSE, return false, L"Unable to find function: %ws::%s", libName, procNameW );
	}

	BOOL success = WriteProcessMemory( process, (void*)address, orig, size, NULL );
	PLUGIN_CHECK_ERROR( success, return false, L"Unable to write debugge memory at: %08X", address );

	return true;
}


bool protectApply( void )
{
	PLUGIN_CHECK_ERROR( process, return false, L"No active debugge found to hook" );

	isDebuggerPresentApply( g_options.isDebuggerPresent );

	return true;
}
